# 3 无重复字串的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

```
示例 1:
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
     
示例 4:
输入: s = ""
输出: 0
```

## 提示

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

# 自己的思路

遍历每个字母开始的字符串，逐个找最长的元素即可。

# 我的代码

```go
func lengthOfLongestSubstring(s string) int {
    ans := 0
    for i,_ := range s{
        dic := make(map[byte]int)
        dic[s[i]]++
        num := 1
        for k := i+1; k < len(s); k++{
            _,ok := dic[s[k]]; if ok{
                break
            }else{
                dic[s[k]]++
                num++
            }
        }
        ans = max(ans,num)
    }
    return ans
}

func max(a,b int) int{
    if a >= b{
        return a
    }else{
        return b
    }
}
```

# 更好的思路

## 滑动窗口

如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 $r_k$ 。那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到$r_k$的字符显然是不重复的，并且由于少了原本的第 k 个字符，我们可以尝试继续增大 $r_k$ ，直到右侧出现了重复字符为止。

这样一来，我们就可以使用「滑动窗口」来解决这个问题了：

- 我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 $r_k$
- 在每一步的操作中，我们会将左指针向右移动一格，表示 我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；
- 在枚举结束后，我们找到的最长的子串的长度即为答案。

**判断重复字符**

在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，我们往哈希集合中添加一个字符。

# 规范代码

```go
func lengthOfLongestSubstring(s string) int {
    // 哈希集合，记录每个字符是否出现过
    m := map[byte]int{}
    n := len(s)
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    rk, ans := -1, 0
    for i := 0; i < n; i++ {
        if i != 0 {
            // 左指针向右移动一格，移除一个字符
            delete(m, s[i-1])
        }
        for rk + 1 < n && m[s[rk+1]] == 0 {
            // 不断地移动右指针
            m[s[rk+1]]++
            rk++
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = max(ans, rk - i + 1)
    }
    return ans
}

func max(x, y int) int {
    if x < y {
        return y
    }
    return x
}

```

# 思考

自己的方法实属笨比，还是$O(n^2)$复杂度的。

