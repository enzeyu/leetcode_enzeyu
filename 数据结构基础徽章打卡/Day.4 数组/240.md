# 搜索二维矩阵2

编写一个高效的算法来搜索 `m x n` 矩阵 matrix 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

```
示例1：
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true

示例2：
输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false
```

## 提示

- m == matrix.length
- n == matrix[i].length
- 1 <= n, m <= 300
- $-10^9 <= matix[i] [j] <= 10^9$
- 每行的所有元素从左到右升序排列
- 每列的所有元素从上到下升序排列
- $-10^9 <= target <= 10^9$

# 自己的思路

其实遍历是最简单的方法，但是这道题显然需要使用有序的情况。



从第一个元素出发，比较元素和target大小，按照先右后下的原则进行查找。

# 我的代码

```go
// 遍历方法
func searchMatrix(matrix [][]int, target int) bool {
    m := len(matrix)
    n := len(matrix[0])
    for i := 0; i < m; i++{
        for j := 0; j < n; j++{
            if matrix[i][j] == target{
                return true
            }
        }
    }
    return false
}
```

# 更好的思路

## 方法4

因为矩阵的行和列是排序的（分别从左到右和从上到下），所以在查看任何特定值时，我们可以修剪O(m)或O(n)元素。

首先，我们初始化一个指向矩阵左下角的 `(row，col)` 指针。然后，直到找到目标并返回 `true`（或者指针指向矩阵维度之外的 `(row，col) `为止，我们执行以下操作：如果当前指向的值大于目标值，则可以 “向上” 移动一行。 否则，如果当前指向的值小于目标值，则可以移动一列。不难理解为什么这样做永远不会删减正确的答案；因为行是从左到右排序的，所以我们知道当前值右侧的每个值都较大。 因此，如果当前值已经大于目标值，我们知道它右边的每个值会比较大。也可以对列进行非常类似的论证，因此这种搜索方式将始终在矩阵中找到目标（如果存在）。

对“方法四”的“如何选出发点”的补充：

- 选左上角，往右走和往下走都增大，不能选
- 选右下角，往上走和往左走都减小，不能选
- 选左下角，往右走增大，往上走减小，可选
- 选右上角，往下走增大，往左走减小，可选

# 规范代码

```go
func searchMatrix(matrix [][]int, target int) bool {
    m := len(matrix)
    n := len(matrix[0])
    if m == 0 || n == 0{
        return false
    }
    i := m-1
    j := 0
    
    for i >= 0 && j < n{
        if matrix[i][j] == target{
            return true
        } else if matrix[i][j] > target{
            i = i-1
        }else{
            j = j+1
        }
    } 
    return false
}
```

# 思考

方法4很巧妙，选择起点的不同就可以决定遍历结果。

