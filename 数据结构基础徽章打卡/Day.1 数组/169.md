# 多数元素

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

```
示例 1：
输入：[3,2,3]
输出：3

示例 2：
输入：[2,2,1,1,1,2,2]
输出：2
```

## 提示

- **进阶：**
  - 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

# 自己的思路

套用之前时间复杂度和空间复杂度都为O(n)的方法，注意这时候出现次数的判别需要满足`v >= len(nums)/2+1`。

# 我的代码

```go
func majorityElement(nums []int) int {
    dict := make(map[int]int)
    target := -1
    for _ , i := range nums{
        if _, ok := dict[i]; ok {
            dict[i]++
        } else{
            dict[i] = 1
        }
    }

    for k , v := range dict{
        if v >= len(nums)/2+1{
            target = k
        }
    }
    return target
}
```

# 更好的思路

#### 随机化

因为超过 n/2 的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。

由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它是否是众数，如果是就返回，否则继续随机挑选。

#### Boyer-Moore投票算法

如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 `0`，从结果本身我们可以看出众数比其他数多。

# 规范代码

```go

```

# 思考

这里给的方法有很多，值得拿出来说的是随机化方法以及投票法。

