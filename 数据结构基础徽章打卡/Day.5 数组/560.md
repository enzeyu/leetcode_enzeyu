# 和为k的子数组

给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 **k** 的连续的子数组的个数。

```
示例 1 :
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

## 提示

- 数组的长度为 [1, 20,000]。
- 数组中元素的范围是 [-1000, 1000] ，且整数 **k** 的范围是 [-1e7, 1e7]。

# 自己的思路

暴力枚举下标和，但是这样做的复杂度会很高，然后又想到了动态规划，考虑以某个元素为结尾的子数组，。

# 我的代码

```go

```

# 更好的思路

### 方法1：暴力

考虑以 i 结尾且和为 k 的连续子数组个数，需要统计符合条件的下标 j 的个数，其中 0≤j≤i 且 [j..i] 这个子数组的和恰好为 k 。

我们可以枚举[0..i] 里所有的下标 j 来判断是否符合条件，注意复杂度可为$O(n^2)$。

### 方法2：前缀和+哈希表优化

我们可以基于方法一利用数据结构进行进一步的优化，我们知道方法一的瓶颈在于对每个`i`，我们需要枚举所有的 `j` 来判断是否符合条件，这一步可以优化。

我们定义 `pre[i]` 为 `[0..i]` 里所有数的和，则 `pre[i]` 可以由 `pre[i−1]` 递推而来，即：
`pre[i]=pre[i−1]+nums[i]`

那么`[j..i]` 这个子数组和为 `k`这个条件我们可以转化为
`pre[i]−pre[j−1]==k`

所以我们考虑以 `i`结尾的和为 `k` 的连续子数组个数时只要统计有多少个前缀和为 `pre[i]−k `的 `pre[j]` 即可。我们建立哈希表 `mp`，以和为键，出现次数为对应的值，记录 `pre[i]` 出现的次数，从左往右边更新 `mp` 边计算答案，那么以 `i` 结尾的答案 `mp[pre[i]−k]` 即可在 `O(1)` 时间内得到。最后的答案即为所有下标结尾的和为 `k` 的子数组个数之和。

需要注意的是，从左往右边更新边计算的时候已经保证了\textit{mp}[\textit{pre}[i]-k]mp[pre[i]−k] 里记录的 \textit{pre}[j]pre[j] 的下标范围是 0\leq j\leq i0≤j≤i 。同时，由于\textit{pre}[i]pre[i] 的计算只与前一项的答案有关，因此我们可以不用建立 \textit{pre}pre 数组，直接用 \textit{pre}pre 变量来记录 pre[i-1]pre[i−1] 的答案即可。



# 规范代码

```go
// 暴力
func subarraySum(nums []int, k int) int {
    count := 0
    for start := 0; start < len(nums); start++ {
        sum := 0
        for end := start; end >= 0; end-- {
            sum += nums[end]
            if sum == k {
                count++
            }
        }
    }
    return count
}

// 方法2
func subarraySum(nums []int, k int) int {
    count, pre := 0, 0
    m := map[int]int{}
    m[0] = 1
    for i := 0; i < len(nums); i++ {
        pre += nums[i]
        if _, ok := m[pre - k]; ok {
            count += m[pre - k]
        }
        m[pre] += 1
    }
    return count
}

```

# 思考

方法2利用了一点公式变形，较为巧妙。

