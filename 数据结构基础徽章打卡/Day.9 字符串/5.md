# 最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

```
示例 1：
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

示例 2：
输入：s = "cbbd"
输出："bb"

示例 3：
输入：s = "a"
输出："a"

示例 4：
输入：s = "ac"
输出："a"
```

## 提示

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成

# 自己的思路

一开始想的是双指针同时指向字符串首尾，但是这样的方法无法识别"abccb"里的"bccb"。

然后就是枚举所有的子串，判断是否是回文字符串，返回最长的，这里考虑从最长的子串进行枚举，然后逐个递减，但是怎么枚举是个问题。

然后想到动态规划，因为某个字符串的回文数判断其实对增加一个字母的字符串是有用的，例如“ab”对"bab"的回文数判断是有用的，但是状态如何转移是一个问题。

最后使用了暴力的思路，枚举所有的子串。

# 我的代码

```go
func longestPalindrome(s string) string {
    length := len(s)
    if length == 1{
        return s
    }
    ans := ""

    for i := 0; i < length; i++{
        for j := i+1; j <= length; j++{
            if isPalindrome(s[i:j]) == true && len(s[i:j]) > len(ans){
                ans = s[i:j]
            }
        }
    }
    return ans 
}

func isPalindrome(s string) bool{
    i,j := 0,len(s)-1
    for i <= j{
        if s[i] != s[j]{
            return false
        }
        i++
        j--
    }
    return true
}
```

# 更好的思路

**方法一：动态规划**

对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。

根据这样的思路，我们就可以用动态规划的方法解决本题。我们用 P(i,j) 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成 s[i:j]）是否为回文串：

P(i,j)=true   如果子串$S_i...S_j$是回文串

P(i,j)=false   其他情况

这里的其他情况包含两个可能。

- s[i, j] 本身不是一个回文串；
- i > j，此时 s[i, j] 本身不合法。

可以写出来状态转移方程：P*(*i*,*j*)=*P*(*i*+1,*j*−1)∧(*S_i*==*S_j)

也就是说，只有 s[i+1:j-1] 是回文串，并且 s 的第 i和 j个字母相同时，s[i:j]才会是回文串。

上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的边界条件，即子串的长度为 1 或 2。对于长度为 1的子串，它显然是个回文串；对于长度为 2的子串，只要它的两个字母相同，它就是一个回文串。因此我们就可以写出动态规划的边界条件：

- *P*(*i*,*i*)=true
- *P*(*i*,*i*+1)=(*S_i*==*S_i*+1)

根据这个思路，我们就可以完成动态规划了，最终的答案即为所有 P(i,j)=true 中 j−i+1（即子串长度）的最大值。注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。

# 规范代码

设`dp[i][k]`数组表示k~i范围的字符串是否是回文。

```go
func longestPalindrome(s string) string {
	dp := make([][]bool, len(s))
	for i := 0; i < len(s); i++ {
		dp[i] = make([]bool, len(s))
	}
	ans := ""
	for i := 0; i < len(s); i++ {
		for k := 0; k <= i; k++ {
			dp[i][k] = s[i] == s[k] && (i-1 < k+1 || dp[i-1][k+1])
			if dp[i][k] && i-k+1 > len(ans) {
				ans = s[k : i+1]
			}
		}
	}
	return ans
}
```

# 思考

动态规划写法可以看一下。

