# 1576 替换所有的问号

给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。

注意：你不能修改非 '?' 字符。

题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。

在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。

```
示例 1：
输入：s = "?zs"
输出："azs"
解释：该示例共有 25 种解决方案，从 "azs" 到 "yzs" 都是符合题目要求的。只有 "z" 是无效的修改，因为字符串 "zzs" 中有连续重复的两个 'z' 。

示例 2：
输入：s = "ubv?w"
输出："ubvaw"
解释：该示例共有 24 种解决方案，只有替换成 "v" 和 "w" 不符合题目要求。因为 "ubvvw" 和 "ubvww" 都包含连续重复的字符。

示例 3：
输入：s = "j?qg??b"
输出："jaqgacb"

示例 4：
输入：s = "??yw?ipkj?"
输出："acywaipkja"
```

## 提示

- `1 <= s.length <= 100`
- `s` 仅包含小写英文字母和 `'?'` 字符

# 自己的思路

为了统一处理，给字符串首尾添加元素，取字符串长度为l，遍历字符串元素，寻找是？的元素。

取一个26个字母的slice，每次需要替换的时候进行遍历即可。

# 我的代码

```go
func modifyString(s string) string {
    chars := []rune{}
    for i := 'a'; i <= 'z'; i++{
        chars = append(chars,i)
    }
    new_s := []rune(s)
    new_s = append(new_s,'-')
    new_s = append([]rune{'-'},new_s...)
    for i,j := range new_s{
        if j == '?'{
            for _,k := range chars{
                if k != new_s[i-1] && k != new_s[i+1]{
                    new_s[i] = k
                    break
                }
            }
        }
    }
    return string(new_s)[1:len(new_s)-1]
}
```

# 更好的思路



# 规范代码

```go

```

# 思考

下次看到这样的题直接进行一个首尾增加。

