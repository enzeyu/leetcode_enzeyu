# 79 单词搜索

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

```
示例 1：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

示例 2：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true

示例 3：
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

## 提示

- m == board.length
- n = board[i].length
- 1 <= m, n <= 6
- 1 <= word.length <= 15
- board 和 word 仅由大小写英文字母组成

# 自己的思路

回忆一下自己以前写回溯，这道题的思路很像，首先需要在某个单元格进行上下左右的四步判定，先进行走，走不通了再回退一步。最终的条件是组成的字符串和word相同，即对函数进行退出，返回true，如果遍历到终点则返回false。

自己的思路还是有问题，这道题需要把每个格子都作为起点来遍历一遍。

# 我的代码

```go

```

# 更好的思路

## 回溯

- 以"SEE"为例，首先要选起点：遍历矩阵，找到起点S。
- 起点可能不止一个，基于其中一个S，看看能否找出剩下的"EE"路径。
- 下一个字符E有四个可选点：当前点的上、下、左、右。
- 逐个尝试每一种选择。基于当前选择，为下一个字符选点，又有四种选择。
- 每到一个点做的事情是一样的。DFS 往下选点，构建路径。
- 当发现某个选择不对，不用继续选下去了，结束当前递归，考察别的选择。

关注当前考察的点，处理它，其他丢给递归子调用去做。

判断当前选择的点，本身是不是一个错的点。

剩下的字符能否找到路径，交给递归子调用去做。

如果当前点是错的，不用往下递归了，返回false。否则继续递归四个方向，为剩下的字符选点。
那么，哪些情况说明这是一个错的点：

当前的点，越出矩阵边界。
当前的点，之前访问过，不满足「同一个单元格内的字母不允许被重复使用」。
当前的点，不是目标点，比如你想找 E，却来到了 D。

# 规范代码

```go

```

# 思考



