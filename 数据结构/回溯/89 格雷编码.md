# 89 格雷编码

n 位格雷码序列 是一个由 $2^n$ 个整数组成的序列，其中：

- 每个整数都在范围 [0, $2^n - 1$] 内（含 0 和 $2^n - 1$）
- 第一个整数是 0
- 一个整数在序列中出现 不超过一次
- 每对 相邻 整数的二进制表示 恰好一位不同 ，且
- 第一个 和 最后一个 整数的二进制表示 恰好一位不同

给你一个整数 n ，返回任一有效的 n 位格雷码序列 。

```
示例 1：
输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同

示例 2：
输入：n = 1
输出：[0,1]
```

## 提示

- `1 <= n <= 16`

# 自己的思路

G了没啥思路，想找规律也没找出来，当n=3时的有效格雷码序列是[0,1,3,2,6,7,5,4]。

# 我的代码

```go

```

# 更好的思路

利用对称性，假设我们知道n−1的构造，那么我们将这个构造反转并拼在后面，在这个反转里每个数的二进制第一位补上1，就得到了n的构造。

- n−1的构造本身不管是正序还是倒序，相邻之间都是差1，而在反转中所有数都在第一位加了一个1，差异不变。
- 反转后，原先最后一位会和自己相邻，加了一个1以后，差异正好是一位。
- 反转后，原先第一位会成为最后一位，后第一位首尾相邻，加了一个1以后，差异正好是一位。

设n位格雷编码Gray(n)，通过下列操作构造出Gray(n+1)

1. n位格雷编码：$Gray(n)=[G_1,G_2,...G_{2^n-1},G_{2^n}]$
2. 倒序格雷编码：$Gray^{-1}(n)=[G_{2^n},G_{2^n-1}...G_2,G_1]$
3. 在倒叙格雷编码的最高位加1，$Gray^{'}(n)=[2^n+G_{2^n},2^n+G_{2^n-1}...2^n+G_2,2^n+G_1]$
4. 拼接集合即可$Gray(n+1)=Gray(n)+Gray'(n)$

# 规范代码

```go
func grayCode(n int) []int {
    if n == 1 {
        return []int{0, 1}
    }
    res, add := grayCode(n-1), 1<<(n-1)
    for i := len(res) - 1;i>=0;i--{
        res = append(res, res[i] + add)
    }
    return res
}
```

# 思考

这题有点脑经急转弯了，真想不出来哇。

