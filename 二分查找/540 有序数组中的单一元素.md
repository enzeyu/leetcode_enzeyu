# 有序数组中的单一元素

给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

```
示例 1:
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2

示例 2:
输入: nums =  [3,3,7,7,10,11,11]
输出: 10
```

## 提示

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 105`

 采用的方案可以在 `O(log n)` 时间复杂度和 `O(1)` 空间复杂度中运行吗？

# 自己的思路

遍历数组，寻找某个同时小于后面的数且大于前面的数返回即可。注意这里要在首尾添加元素，以应对越界情况。

# 我的代码

```go
func singleNonDuplicate(nums []int) int {
    nums = append(nums,100001)
    t := []int{-1}
    t = append(t,nums...)
    for i := 1; i <= len(nums); i++{
        if t[i] > t[i-1] && t[i] < t[i+1]{
            return t[i]
        }
    }
    return -1
}
```

# 更好的思路

## 方法一：暴力法

从第一个元素开始，我们检查每个第二个元素是否与当前元素相同。 如果不同，说明该元素是单个元素。

如果我们到达最后一个元素，则它为单一元素。



## 方法二：异或法

这里参考规范代码，很简洁。

# 规范代码

```go
func singleNonDuplicate(nums []int) int {
  ans := 0
  for _, v := range nums {
     ans ^= v
  }
  return ans
}
```

# 思考

自己的方法时间挺快的，但是空间复杂度过高。

