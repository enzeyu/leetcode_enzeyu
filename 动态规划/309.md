# 最佳买卖股票时机含冷冻期

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

```
示例:
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

## 提示



# 自己的思路

直接没思路了，看起来每个股票有好几个状态，只知道要用动规。

# 我的代码(unsolved)

```go

```

# 更好的思路

我们可以使用动态规划的方法，维护在股市中每一天结束后可以获得的「累计最大收益」，并以此进行状态转移，得到最终的答案。

## 方法一：动态规划

用 f[i] 表示第 i 天结束之后的「累计最大收益」。根据题目描述，由于我们最多只能同时买入（持有）一支股票，并且卖出股票后有冷冻期的限制，因此我们会有三种不同的状态：

我们目前持有一支股票，对应的「累计最大收益」记为 `f[i][0]`；
我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 `f[i][1]`；
我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 `f[i][2]`。

如何进行状态转移呢？在第 i 天时，我们可以在不违反规则的前提下进行「买入」或者「卖出」操作，此时第 i 天的状态会从第 i−1 天的状态转移而来；我们也可以不进行任何操作，此时第 i 天的状态就等同于第 i−1 天的状态。那么我们分别对这三种状态进行分析：

对于 `f[i][0]`，我们目前持有的这一支股票可以是在第 i−1 天就已经持有的，对应的状态为 `f[i−1][0]`；或者是第 i 天买入的，那么第 i−1 天就不能持有股票并且不处于冷冻期中，对应的状态为 `f[i−1][2]` 加上买入股票的负收益 `prices[i]`。因此状态转移方程为：

`f[i][0]=max(f[i−1][0],f[i−1][2]−prices[i])`

对于 `f[i][1]`，我们在第 i 天结束之后处于冷冻期的原因是在当天卖出了股票，那么说明在第 i−1 天时我们必须持有一支股票，对应的状态为 `f[i−1][0]` 加上卖出股票的正收益 prices[i]。因此状态转移方程为：

`f[i][1]=f[i−1][0]+prices[i]`

对于 `f[i][2]`，我们在第 i 天结束之后没有股票且没有冷冻期，即当天没有操作，即第i-1天没有股票。这里第i-1天分为两种情况，如果处于冷冻期，对应状态为`f[i-1][1]`，如果不处于冷冻区，对应状态为`f[i-1][2]`，因此状态转移方程为：

`f[i][2]=max(f[i-1][1],f[i-1][2])`

这样我们就得到了所有的状态转移方程。如果一共有 n 天，那么最终的答案即为

 `max(f[n-1][0],f[n-1][1],f[n-1][2])`，在最后一天，即第n-1天结束后，手上有股票是没有意义的，故最终答案为`max(f[n-1][1],f[n-1][2])`



**初始条件：**

在第 0 天时，如果持有股票，那么只能是在第 0 天买入的，对应负收益−prices[0]；如果不持有股票，那么收益为零。注意到第 0 天实际上是不存在处于冷冻期的情况的，但我们仍然可以将对应的状态 f[0] [1] 置为零，这其中的原因留给读者进行思考。

这样我们就可以从第 1 天开始，根据上面的状态转移方程进行进行动态规划，直到计算出第 n−1 天的结果。

# 规范代码

```go
func maxProfit(prices []int) int {
    if len(prices) == 0 {
        return 0
    }
    n := len(prices)
    // f[i][0]: 手上持有股票的最大收益
    // f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益
    // f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
    f := make([][3]int, n)
    f[0][0] = -prices[0]
    for i := 1; i < n; i++ {
        f[i][0] = max(f[i-1][0], f[i-1][2] - prices[i])
        f[i][1] = f[i-1][0] + prices[i]
        f[i][2] = max(f[i-1][1], f[i-1][2]) 
    }
    return max(f[n-1][1], f[n-1][2])
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

# 思考

这道题的动归涉及了三个状态，第一次遇到，需要反复琢磨。

