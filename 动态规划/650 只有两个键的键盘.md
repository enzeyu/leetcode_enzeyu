# 只有两个键的键盘

最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作：

Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
Paste（粘贴）：粘贴 上一次 复制的字符。
给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。

```
示例 1：
输入：3
输出：3
解释：
最初, 只有一个字符 'A'。
第 1 步, 使用 Copy All 操作。
第 2 步, 使用 Paste 操作来获得 'AA'。
第 3 步, 使用 Paste 操作来获得 'AAA'。

示例 2：
输入：n = 1
输出：0
```

## 提示

- `1 <= n <= 1000`

# 自己的思路

这种求解需要以前答案的题目，上动归就好了。

#### 1 确定dp数组意义

dp[i]表示i个字母所需要的次数，则dp[0]=1,dp[1]=1。

#### 2 找出更新公式

当i%2==0的时候，dp[i]=dp[i/2]+2   // 完成一次复制和一次黏贴

当i%2!=0的时候，dp[i]=dp[j]+i/j    j需要满足i/j==0，且j应该从i-1开始算，逐个递减。 //默认已经复制了

#### 3 初始化条件

dp[0]=0，dp[1]=0

# 我的代码

```go
func minSteps(n int) int {
    dp := make([]int,n+1)
    for i := 2; i <= n; i++{
        if i%2 == 0{
            dp[i] = dp[i/2]+2
        }else{
            for j := i/2; j >= 1; j--{
                if i % j == 0{
                    dp[i]=dp[j]+i/j
                    break
                }
            }
        }
    }

    return dp[n]
}
```

# 更好的思路

方法一：分解质因数

我们至少可以观察出：如果 i 为质数，那么 i 是多少，就需要粘贴多少次。即：素数次数为本身的结论。如 两个A = 2，三个A = 3，五个A = 5。

那对于合数又该如何分析呢？（自然数中除能被1和本身整除外,还能被其他的数整除的数）这里我们直接给出答案：合数的次数为将其分解质因数的操作次数的和。

比如30，可以分解为：325。什么意思呢？我们演示一遍：首先复制1，进行2次粘贴得到3。然后复制3，进行1次粘贴得到6。然后复制6，进行4次粘贴得到30。总共需要（CPPCPCPPPP）

# 规范代码

```go
// 分解质因数
func minSteps(n int) int {
	res := 0
	for i := 2; i <= n; i++ {
		for n%i == 0 {
			res += i
			n /= i
		}
	}
	return res
}

// 别人的动态规划
func minSteps(n int) int {
    return method_dp(n)
}
func method_dp(n int) int {
    dp := make([]int, n + 1)
    dp[1] = 0
    for i := 2; i <= n; i++ {
      	// i能整除j，则j至少要<=i/2， 所以j改为遍历=i/2至1
        for j := i / 2; j >= 1; j-- {
            if i % j == 0 {
                // fmt.Println(i,j)
                dp[i] = dp[j] + i / j
                break
            }
        }
    }
    // fmt.Println(dp)
    return dp[n]
}
```

# 思考

这道题在处理的时候，自己似乎有点误打误撞了。当可以整除2的时候，状态应该+2，代表复制一次黏贴一次，再加上原来的一半就完成了。

当不可整除2的时候，找到了最大的因数j，状态应该是+1+i/j-1，第一个i代表复制的，i/j代表共需要复制几次，-1代表去掉已经有的j个。



动归的规律其实就是：

1个A = A = 0
2个A = A + A = dp[1] + 2/1
3个A = A + A + A = dp[1] + 3/1
6个A = AAA + AAA = dp[3] + 6 / 2
9个A = AAA + AAA + AAA = dp[3] + 9/3

