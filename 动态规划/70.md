# 问题

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

```
例1：
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶

例2：
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

# 自己的思路

这个问题其实相当于，从0开始，每次增加1或者每次增加2，有多少种不同的情况，可以到达最后的n。可以注意到，到达n次不同的数目等于到达n-1层和到达n-2层的和。即sum(n)=sum(n-1)+sum(n-2)，使用递归的方式来做，中止条件是当n为1的时候，返回为1，当n为2的时候，返回为2。

```
func climbStairs(n int) int {
    if n == 1{
        return 1
    }else if n == 2{
        return 2
    }else{
        return climbStairs(n-1) + climbStairs(n-2)
    }
}
自己这么写的代码在n=44的时候显示超出时间限制，是不对的。
```

# 正确的思路

自己的思路是正确的，只是没有用简单的方式来做。这个问题可以被分解为一些包含最优子结构的子问题,它的最优解可以从其子问题的最优解来有效地构建,因此我们可以使用**动态规划**解决这个问题。

到达n阶的方法，可以由第n-1阶向上走1步，n-2阶向上走2步。因此到达n阶就等于到达后面2个阶的和。

# 代码

```
func climbStairs(n int) int {
    if n <= 2{
        return n
    }
    a := 1
    b := 2
    for i:= 3;i<=n;i++{
        temp := a + b
        a = b
        b = temp
    }
    return b
}
```

# 思考

这里的解法，其实就是求解斐波那契数列，注意循环的开始和终止条件以及返回的值，即可获得最后答案。