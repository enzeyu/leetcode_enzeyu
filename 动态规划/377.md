# 组合总和4

给你一个由不同整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

```
示例 1：
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。

示例 2：
输入：nums = [9], target = 3
输出：0
```

## 提示

- 1 <= nums.length <= 200
- 1 <= nums[i] <= 1000
- nums 中的所有元素 互不相同
- 1 <= target <= 1000

# 自己的思路

上动态规划，构造dp，每个元素dp[i]代表构成i的不同组合数目。

初始化dp[0]=1，代表当target=0的时候，不取元素是唯一的方案。

对于nums的每个元素j，状态转移方程为dp[i]+=dp[i-j]。

故外层循环为target，即容量，内层循环为nums，即背包。

# 我的代码

```go
func combinationSum4(nums []int, target int) int {
    dp := make([]int, target+1)
    dp[0] = 1

    for i := 1; i <= target; i++{
        for _ , j := range nums{
            if i >= j {
                dp[i] += dp[i-j]
            }
        } 
    }
    return dp[target]
}
```

# 更好的思路

和官方思路一致，但是官方给了一个思考。

上述做法是否考虑到选取元素的顺序？答案是肯定的。因为外层循环是遍历从 `1 `到 `target` 的值，内层循环是遍历数组 `nums` 的值，在计算 `dp[i]` 的值时，`nums `中的每个小于等于 ii 的元素都可能作为元素之和等于 `i` 的排列的最后一个元素。

# 规范代码

```go

```

# 思考

终于对了一次。。。

题目有点相似于零钱兑换问题，即518和322。