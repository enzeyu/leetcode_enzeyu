# 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

```
示例 1：
输入：m = 3, n = 7
输出：28

示例 2：
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下

示例 3：
输入：m = 7, n = 3
输出：28

示例 4：
输入：m = 3, n = 3
输出：6
```

## 提示

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 2 * $10^9$

# 自己的思路

构造出一个m*n的矩阵，每个元素代表从start到它的路径数。当行等于0的时候，从start到达某点的不同路径只有一条，同样的道理适用于当列等于0的情况。而当行列大于0的时候，到达某点的路径等于左边格子+上面格子之和。

# 我的代码

```go
func uniquePaths(m int, n int) int {
    if m==1 && n==1{
        return 1
    }
    ans := make([][]int,m)
    for i:=0; i<m; i++{
        ans[i] = make([]int,n)
    }
    ans[0][0] = 0
    for i:=1; i<m; i++{
        ans[i][0] = 1
    }
    for i:=1; i<n; i++{
        ans[0][i] = 1
    }
    for i:=1; i<m; i++{
        for j:=1; j<n; j++{
            ans[i][j] = ans[i-1][j] + ans[i][j-1]
        }
    }
    return ans[m-1][n-1]
}
```

# 更好的思路

动态方程正确的思路，对动态方程的解释是类似爬楼梯的过程，假设站在[i,j]的地方，那么你上一步是在[i-1,j]向下走到达当前位置或者是从[i,j-1]向右走到达当前位置，因此这个动态方程给的没有问题。

排列组合正确的思路， 要走到右下角一定是向右走m-1步，向下走n-1步。也就是说总共走m-1+n-1=(m+n-2) 步，其中有m-1步是向右的。那么这就是一个组合的问题，从m+n-2步中选择m-1步向右，总共有
$$
C_{m-1}^{m+n-2}
$$
种排列方式。

# 规范代码

```go
func uniquePaths(m, n int) int {
    return int(new(big.Int).Binomial(int64(m+n-2), int64(n-1)).Int64())
}
```

# 思考

排列组合方法很巧妙，可借鉴。

在使用Golang实现排列组合方法的时候，需要使用new(big.Int)构建大整数变量，然后调用Binomial方法。