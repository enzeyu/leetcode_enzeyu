# 202 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
- 如果 可以变为  1，那么这个数就是快乐数。
- 如果 n 是快乐数就返回 true ；不是，则返回 false 。

```
示例 1：
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

示例 2：
输入：n = 2
输出：false
```

## 提示

- `1 <= n <= 231 - 1`

# 自己的思路

首先需要将数字转为字符串，获得每一个数字，计算出当前数的平方。

注意，不是快乐数的条件应该有，在每一次判断产出的结果后，会存在map里。如果这个数不是快乐数，则它产生的中间数一定会重复。

# 我的代码

```go
func isHappy(n int) bool {
    num := strconv.Itoa(n)
    dic := make(map[string]bool)
    for {
        sum := 0
        for _, i := range num{
            sum += int(i -'0') * int(i -'0')
        }
        if sum == 1{
            return true
        } else{
            num = strconv.Itoa(sum)
            if dic[num] == true{
                return false
            }else{
                dic[num] = true
            }
        }      
    }
    return false
}
```

# 更好的思路

## 方法2：快慢指针法

通过反复调用 getNext(n) 得到的链是一个隐式的链表。隐式意味着我们没有实际的链表节点和指针，但数据仍然形成链表结构。起始数字是链表的头 “节点”，链中的所有其他数字都是节点。next 指针是通过调用 getNext(n) 函数获得。

意识到我们实际有个链表，那么这个问题就可以转换为检测一个链表是否有环。因此我们在这里可以使用弗洛伊德循环查找算法。这个算法是两个奔跑选手，一个跑的快，一个跑得慢。在龟兔赛跑的寓言中，跑的慢的称为 “乌龟”，跑得快的称为 “兔子”。

不管乌龟和兔子在循环中从哪里开始，它们最终都会相遇。这是因为兔子每走一步就向乌龟靠近一个节点（在它们的移动方向上）。

**算法**

我们不是只跟踪链表中的一个值，而是跟踪两个值，称为快跑者和慢跑者。在算法的每一步中，慢速在链表中前进 1 个节点，快跑者前进 2 个节点（对 getNext(n) 函数的嵌套调用）。

如果 n 是一个快乐数，即没有循环，那么快跑者最终会比慢跑者先到达数字 1。

如果 n 不是一个快乐的数字，那么最终快跑者和慢跑者将在同一个数字上相遇。

# 规范代码

```go
func isHappy(n int) bool {
    slow, fast := n, step(n)
    for fast != 1 && slow != fast {
        slow = step(slow)
        fast = step(step(fast))
    }
    // slow == fast代表没用快乐数
    return fast == 1
}

func step(n int) int {
    sum := 0
    for n > 0 {
        sum += (n%10) * (n%10)
        n = n/10
    }
    return sum
}
```

# 思考

哈希表，快慢指针是常用解法。

自己取数字的处理不够优雅，使用一个for循环即可。

