# 最小移动次数使数组元素相等2

给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。

```
例如:
输入:
[1,2,3]
输出:
2
说明：
只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： 
[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
```

## 提示

# 自己的思路

对数组进行排序，取中位数为标准，计算每个数字变成中位数所需要移动的步数。这里只需要比较两个，即一左一右。

# 我的代码

```go
func minMoves2(nums []int) int {
    length := len(nums)
    sort.Slice(nums,func(a,b int) bool{
        return nums[a] < nums[b]
    })
    m := nums[length/2]
    ans := 0
    for i := 0; i < length; i++{
        if nums[i] > m{
            ans += (nums[i] - m)
        }
        if nums[i] < m{
            ans += (m - nums[i])
        }
    }
    return ans
}
```

# 更好的思路

## 方法一：使用排序寻找中位数

假设最终数组 a 中的每个数均为 x，那么需要移动的次数即为 |a[0] - x| + |a[1] - x| + ... + |a[n-1] - x|。如果我们把数组 a 中的每个数看成水平轴上的一个点，那么根据上面的移动次数公式，我们需要找到在水平轴上找到一个点 x，使得这 N 个点到 x 的距离之和最小。

这是一个经典的数学问题，当 x 为这个 N 个数的中位数时，可以使得距离最小。具体地，若 N 为奇数，则 x 必须为这 N 个数中的唯一中位数；若 N 为偶数，中间的两个数为 p 和 q，中位数为 (p + q) / 2，此时 x 只要是区间 [p, q] 中的任意一个数即可。

因此，我们只需要找到这个 N 个数的中位数，并计算距离之和。我们可以直接将数组进行排序，这样就直接得到了中位数。



这是个典型的相遇问题，移动距离最小的方式是所有元素都移动到中位数。理由如下：

设 m 为中位数。a 和 b 是 m 两边的两个元素，且 b > a。要使 a 和 b 相等，它们总共移动的次数为 b - a，这个值等于 (b - m) + (m - a)，也就是把这两个数移动到中位数的移动次数。

设数组长度为 N，则可以找到 N/2 对 a 和 b 的组合，使它们都移动到 m 的位置。

# 规范代码

```go

```

# 思考

自己的就是双百答案，无规范，这道题最难的地方在于，如何把自己想到的中位数是答案证明出来。

