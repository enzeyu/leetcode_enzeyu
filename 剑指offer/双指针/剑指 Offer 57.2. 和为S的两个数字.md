# 剑指 Offer 57.2 和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

```
示例 1：
输入：target = 9
输出：[[2,3,4],[4,5]]

示例 2：
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```

## 提示

- `1 <= target <= 10^5`

# 自己的思路

数字取值的范围只能是1到（n+1）/2。故只需要双指针遍历即可，即对每个索引开始索引，计算两个指针之间的和，如果小于则右指针往右，说白了自己就是暴力法，真别玩了。

这里自己卡在了如何构造不确定长度的二维数组里，后来发现其实不用纠结这个，slice自己动态扩容。

# 我的代码

```

```



# 更好的思路

## 方法一：滑动窗口

滑动窗口可以看成数组中框起来的一个部分。在一些数组类题目中，我们可以用滑动窗口来观察可能的候选结果。当滑动窗口从数组的左边滑到了右边，我们就可以从所有的候选结果中找到最优的结果。

对于这道题来说，数组就是正整数序列 [1, 2, 3, ... n]。我们设滑动窗口的左边界为 i，右边界为 j，则滑动窗口框起来的是一个左闭右开区间 [i,j)。注意，为了编程的方便，滑动窗口一般表示成一个左闭右开区间。在一开始，i=1, j=1，滑动窗口位于序列的最左侧，窗口大小为零。

滑动窗口的重要性质是：**窗口的左边界和右边界永远只能向右移动**，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)。滑动窗口只有 **右边界向右移动（扩大窗口）** 和 **左边界向右移动（缩小窗口）** 两个操作，所以实际上非常简单。

要用滑动窗口解这道题，我们要回答两个问题：

- 第一个问题，窗口何时扩大，何时缩小？
- 第二个问题，滑动窗口能找到全部的解吗？

第一个问题，答案如下

- 当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动
- 当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动
- 当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为 [i, j)，那么我们已经找到了一个 ii 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动

第二个问题，滑动窗口的左右边界都不需要向左移动，所以这道题用滑动窗口一定可以得到所有的解。

# 规范代码

```go
// 滑动窗口
func findContinuousSequence(target int) [][]int {
    i, j, sum := 1, 1, 0
    ret := make([][]int, 0)
    // 也可以改成/2
    for i <= target>>1 {
        // 如果和小于目标，则右指针前进一位
        if sum < target {
            sum += j
            j++
        } else if sum > target { // 如果大于目标，左指针前进一位
            sum -= i
            i++
        } else {
            // 构建长度为j-i的滑动窗口
            tmp := make([]int, 0, j-i)
            for m := i; m < j; m++ {
                tmp = append(tmp, m)
            }
            ret = append(ret, tmp)
            sum -= i
            i++
        }
    }
    return ret
}
```

# 思考

滑动窗口方法值得再看，看似是暴力法实则不是。