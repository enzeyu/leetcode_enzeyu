# 问题

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

```
示例1：
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

示例2:
输入: m = 7, n = 3
输出: 28

提示：
1.1<=m,n<=100
2.题目数据保证答案小于等于2*10^9
```

# 自己的思路

题目给的分类是动态规划，显然这也不是一个常规解法可以接出来的问题。自己借助了动规经典的背包问题，建立m*n的表格，以4×4为例子，发现路线数等于左边元素以及上边元素的和。因此问题就变得简单了。构建对应的二维数组，赋值即可。

# 正确的思路

啊这，我的思路是对的，但是感觉有一点碰的嫌疑。标准解答是我找到的规律用于动态方程，所以这样就算出来了。

动态方程正确的思路，对动态方程的解释是类似爬楼梯的过程，假设站在[i,j]的地方，那么你上一步是在[i-1,j]向下走到达当前位置或者是从[i,j-1]向右走到达当前位置，因此这个动态方程给的没有问题。

排列组合正确的思路， 要走到右下角一定是向右走m-1步，向下走n-1步。也就是说总共走m-1+n-1 (m+n-2) 步，其中有m-1步是向右的。那么这就是一个组合的问题，从m+n-2步中选择m-1步向右，总共有
$$
C_{m-1}^{m+n-2}
$$
种排列方式。

# 正确代码

```
//空间复杂度为O(mn)
func uniquePaths(m int, n int) int {
    //新建解答的数组
    array := make([][]int , m)
    for i := 0; i < m; i++ {
        array[i] = make([]int, n)
        array[i][0] = 1
    }
    for i := 1; i < n; i++ {
        array[0][i] = 1
    }
    for i := 1; i<m ; i++{
        for j := 1; j<n ; j++{
            array[i][j] = array[i-1][j] + array[i][j-1]
        }
    }
    return array[m-1][n-1]    

}

//空间复杂度为O(n)的算法，使用golang实现,但是会超时
func uniquePaths(m int, n int) int {
    //新建解答的数组
    array := make([]int , n)   
	for i := 0; i<n ; i++{
		array[i] = 1
	}
	for i := 1; i<m ; i++{
		for j := 1; j<n ; i++{
			array[j] = array[j-1] + array[j]	
		}
	}
	return array[n-1]
}

//这里给出空间复杂度为O(n)的算法，使用python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        cur = [1] * n
        for i in range(1, m):
            for j in range(1, n):
            	//这里相当于是左边的值+上一行对应的值
                cur[j] += cur[j-1]
        return cur[-1]
```

# 思考

很多时候，确实要画个图，排列组合的思路真的很妙。